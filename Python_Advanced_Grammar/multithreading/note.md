# 多线程 VS 多进程
 - 程序: 一堆代码以文本形式存入一个文档中
 - 进程: 程序运行的一个状态
    - 包含地址空间、内存、数据栈等
    - 每个进程有自己完全独立的运行环境,多进程共享数据是一个问题
 - 线程
    - 一个进程的独立运行片段,一个进程可以由多个线程组成
    - 轻量化的进程
    - 一个进程的多个线程间共享数据和上下文运行环境
    - 共享和互斥问题
 - 全局解释器锁(GIL)
    - Python代码的执行是由Python虚拟机进行控制
    - 在主循环中只能有一个控制线程在执行
 - Python包(案例见ex01和ex02比较,案例ex03)
    - thread: 有问题 不好用,Python3改成了_thread
    - threading: 通行的包
 - threading的使用 (案例见ex04)
    - 直接利用threading.Thread生成Thread实例
        - 1. t = threading.Thread(target=xxx, args=(xxx,))
        - 2. t.start(): 启动线程
        - 3. t.join(): 等待多线程执行完成
    - 守护线程:daemon
        - 如果在程序中将子线程设置成守护线程,则子线程会在主线程结束的时候自动退出
        - 一般认为,守护线程中不重要或者不允许离开主线程独立运行
        - 守护线程案例是否有效果与环境有关(见案例ex05和ex06)
    - 线程常用属性(案例见 ex07): 
        - threading.currentThread: 返回当前线程变量
        - threading.enumrate: 返回一个正在运行的线程的list
        - threading.activeCount: 返回正在运行的线程数量 == len(threading.enumrate)
        - thr.setName: 给线程设置名字
        - thr.getName:
    - 直接继承自threading.Thread(案例见ex08)
        - 直接继承Thread
        - 重写run函数
        - 类实例可以直接运行
        - 实用写法(案例见ex09)
 - 共享变量(案例见ex10)
    - 当多个线程同时访问一个变量的时候,会产生共享变量的问题
    - 解决变量共享问题:锁或者信号灯
    - 锁(Lock)
        - 是一个标志,表示一个线程在占用一些资源
        - 使用方法
            - 上锁
            - 使用共享资源,放心使用
            - 取消锁,释放锁
        - 一般拿来锁多线程中的互斥资源(被多线程共享的资源)
        - 锁其实不是锁住谁,而是一个令牌,提示别的没有获得锁的线程无法访问
    - 线程安全问题:
        - 如果一个资源/变量,他对于多线程来讲,不加锁也不会引起任何问题,则称为线程安全
        - 线程不安全变量类型: list,set,dict
        - 线程安全变量类型: queue
    - 生产者消费者问题:
        - 一个模型,可以用来搭建消息队列(案例见ex11)
        - queue是一个用来存放变量的数据结构,特点是先进先出,内部元素排队,就是一个特殊的list
    - 死锁问题(案例见ex12):
    - 锁的等待时间问题(案例见ex13)
    - semphore(案例见ex14)
        - 允许一个资源最多由几个多线程同时使用
    - Timer(案例见ex15)
        - Timer是利用多线程,在指定时间后启动一个函数功能
    - 可重入锁(案例见ex16)
        - 一个锁,可以被一个线程多次申请
        - 主要解决递归调用的时候,需要申请锁的情况
        
# 线程替代方案
 - subprocess
    - 完全跳过线程,使用进程
    - 是派生进程的主要替代方案
    - python2.4之后引入
 - multiprocessiong
    - 使用threading接口派生,使用子进程
    - 允许为多核或者多cpu派生进程,接口跟threading非常相似
    - Python2.6开始引入
 - concurrent.futures
    - 新的异步执行模块
    - 任务级别的操作
    - Python3.2后引入

# 多进程
 - 进程间通讯(InterprocessCommunication,IPC)
 - 进程直接无任何共享状态
 - 进程的创建
    - 直接生成Process实例对象(案例见ex17)
    - 生成派生对象(案例见ex18)
 - 在os中看成pid,ppid以及他们的关系(案例见ex19)
 - 进程实现生产者消费者模型(案例见ex20)
    - JoinableQueue
    - 队列中可以使用哨兵(案例见ex21)
    - 哨兵的改进(案例见ex22)
    